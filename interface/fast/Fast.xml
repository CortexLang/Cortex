<meta xmlns:meta="https://hyve.com/meta">
	<meta:scope name="cortex">
		<!-- hyve::fast -->
		<meta:scope name="Fast">
			<!-- Enumeration representing the values that can be represented in hyve -->
			<enum name="valueKind">
				<meta:scope>
					<constant name="Bool"/>
					<constant name="Char"/>
					<constant name="Int"/>
					<constant name="SignedInt"/>
					<constant name="Float"/>
					<constant name="Text"/>
					<constant name="Enum"/>
					<constant name="Ref"/>
					<constant name="Nothing"/>
				</meta:scope>
			</enum>
			
			<function name="valueKindFromType(lang::type type)" returnType="valueKind"/>
			<function name="report(string kind,string filename,uint32 line,uint32 column,string error,string token)"/>
			<function name="reportError(string filename,uint32 line,uint32 column,string error,string token)"/>
			<function name="reportWarning(string filename,uint32 line,uint32 column,string error,string token)"/>
			<function name="isOperatorAssignment(operatorKind operator)" returnType="bool"/>
			
			<!-- Enumeration representing the different treenode kinds -->
			<enum name="nodeKind">
				<meta:scope>
					<constant name="BinaryExpr"/>
                    <constant name="CallExpr"/>
					<constant name="CastExpr"/>
                    <constant name="CommaExpr"/>
                    <constant name="DeclarationExpr"/>
					<constant name="DeclareExpr"/>
					<constant name="DefineExpr"/>
					<constant name="IfExpr"/>
                    <constant name="InitializerExpr"/>
					<constant name="LiteralExpr"/>
					<constant name="MethodExpr"/>
					<constant name="NewExpr"/>
					<constant name="PostfixExpr"/>
                    <constant name="TernaryExpr"/>
					<constant name="UnaryExpr"/>
                    <constant name="UpdateExpr"/>
                    <constant name="StorageExpr"/>
                    <constant name="WaitExpr"/>
                    <constant name="WhileExpr"/>
				</meta:scope>
			</enum>

			<!-- Base node -->
			<class name="Node">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<member name="kind" type="nodeKind"/>
                    <member name="line" type="uint32" modifiers="readonly"/>
                    <member name="column" type="uint32" modifiers="readonly"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<meta:object name="Storage" type="class"/>

			<enum name="derefKind">
				<meta:scope>
					<constant name="ByValue"/>
					<constant name="ByReference"/>
				</meta:scope>
			</enum>
			
			<!-- Base expression node -->
			<class name="Expression" base="Node">
				<meta:scope>
					<member name="type" type="type" modifiers="readonly"/>
					<member name="isReference" type="bool" modifiers="readonly"/>
					<member name="deref" type="derefKind" modifiers="readonly"/>
					<method name="getType()" returnType="type"/>
					<method name="getType_expr(Expression target)" returnType="type"/>
					<method name="getType_type(type target)" returnType="type"/>
					<virtual name="serialize(type dstType,word dst)" returnType="int16"/>
					<method name="cast(type type,bool isReference)" returnType="Fast::Expression"/>
					<virtual name="fold()" returnType="Fast::Expression"/>
					<virtual name="getValue()" returnType="word"/>
                    <virtual name="toList()" returnType="list{Expression}"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <function name="fromList(list{Expression} list)" returnType="Expression"/>
                    <function name="cleanList(list{Expression} list)"/>
				</meta:scope>
			</class>
            
            <!-- Comma expression node -->
            <class name="Comma" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="construct()" returnType="int16"/>
                    <member name="expressions" type="list{Expression}" modifiers="private"/>
                    <method name="addExpression(Expression expr)" returnType="int16"/>
                    <method name="toList()" returnType="list{Node}"/>
                    <function name="addOrCreate(Expression list,Expression expr)" returnType="Expression"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
                </meta:scope>
            </class>

			<!-- Base literal node -->
			<class name="Literal" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<member name="kind" type="valueKind"/>
					<virtual name="getValue()" returnType="word"/>
				</meta:scope>
			</class>
			
			<!-- Boolean literal -->
			<class name="Boolean" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Character literal -->
			<class name="Character" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="char"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Integer literal -->
			<class name="Integer" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="uint64"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Signed integer literal -->
			<class name="SignedInteger" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="int64"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Floating point literal -->
			<class name="FloatingPoint" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="float64"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Null literal -->
			<class name="Null" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Enumeration representing the different variable kinds -->
			<enum name="storageKind">
				<meta:scope>
					<constant name="LocalStorage"/>
					<constant name="ObjectStorage"/>
					<constant name="MemberStorage"/>
					<constant name="ElementStorage"/>
					<constant name="TemplateStorage"/>
				</meta:scope>
			</enum>

			<!-- Base variable node -->
			<class name="Storage" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="kind" type="storageKind"/>
				</meta:scope>
			</class>
			

			<!-- Different kinds of locals -->
			<enum name="LocalKind">
				<meta:scope>
					<constant name="LocalDefault"/>
					<constant name="LocalParameter"/>
					<constant name="LocalReturn"/>
				</meta:scope>
			</enum>

			<!-- Local variable node -->
			<class name="Local" base="Storage" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="name" type="string"/>
					<member name="type" type="type"/>
					<member name="kind" type="Fast::LocalKind"/>
					<member name="reference" type="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Observer template variable -->
			<class name="Template" base="Local">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
				</meta:scope>
			</class>

			<!-- Object variable node -->
			<class name="Object" base="Storage" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
					<method name="getValue()" returnType="word"/>
					<member name="value" type="object"/>
				</meta:scope>
			</class>

			<!-- Forward declaration of while -->
            <meta:object name="While" type="class"/>
			
			<!-- Statement block -->
			<class name="Block" base="Node" baseAccess="readonly">
				<meta:scope>
					<member name="parent" type="Fast::Block"/>
					<member name="isRoot" type="bool" modifiers="readonly"/>
					<member name="statements" type="list{Fast::Node}" modifiers="private|local"/>
					<member name="locals" type="list{Fast::Local}" modifiers="private|local"/>
					<member name="function" type="function" modifiers="readonly"/>
                    <member name="while" type="Fast::While" modifiers="readonly"/>
					<method name="setFunction(function function"/>
					<method name="declare(string id,type type,bool isParameter,bool isReference)" returnType="Fast::Local"/>
					<method name="declareTemplate(string id,type type,bool isParameter,bool isReference)" returnType="Fast::Template"/>
					<method name="declareReturnVariable(function function)" returnType="Fast::Local"/>
					<method name="lookup(string id)" returnType="Fast::Expression"/>
					<method name="lookupLocal(string id)" returnType="Fast::Local"/> <!-- Only search for locals -->
					<method name="resolve(string id)" returnType="Fast::Expression"/>
					<method name="resolveLocal(string id)" returnType="Fast::Local"/>
					<method name="addStatement(Fast::Node statement)"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
                    <virtual name="toIcBody(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Member expression -->
			<class name="Member" base="Storage" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="Fast::Expression"/>
					<member name="rvalue" type="Fast::Expression"/>
					<member name="superMember" type="bool" modifiers="readonly"/>
					<member name="member" type="object" modifiers="private"/> <!-- Only set when determined at compile-time -->
                    <virtual name="hasSideEffects()" returnType="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Element expression -->
			<class name="Element" base="Storage" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="Fast::Expression"/>
					<member name="rvalue" type="Fast::Expression"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Call expression -->
			<class name="Call" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>

					<member name="instanceExpr" type="Fast::Expression"/>
					<member name="arguments" type="Fast::Expression"/>
					<member name="functionExpr" type="Fast::Expression" modifiers="readonly"/>
					<member name="instanceIsAny" type="bool" modifiers="readonly"/>

					<member name="returnType" type="type" modifiers="readonly"/>
					<member name="returnsReference" type="bool" modifiers="readonly"/>
					<member name="parameters" type="sequence{parameter}" modifiers="readonly"/>
					<member name="overloaded" type="bool" modifiers="readonly"/>
					
					<method name="setParameters(function function)"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>

			<!-- Compiler-defined function call -->
			<class name="StaticCall" base="Call">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="function" type="function"/>
				</meta:scope>
			</class>

			<!-- Runtime-defined (delegate) function call -->
			<class name="DelegateCall" base="Call">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="expr" type="Fast::Expression"/>
				</meta:scope>
			</class>

			<!-- Helps finding the correct procedure given a name and argumentlist and build call expression -->
			<struct name="CallBuilder">
				<meta:scope>
					<member name="name" type="string"/>
					<member name="arguments" type="Fast::Expression"/>
					<member name="instance" type="Fast::Expression"/>
					<member name="scope" type="object"/>
					<member name="block" type="Fast::Block"/>
					<member name="overloaded" type="bool" modifiers="local|private"/>
					<member name="signature" type="string" modifiers="local|private"/>
					<method name="buildSignature()" returnType="int16"/>
					<method name="build()" returnType="Fast::Call"/>
				</meta:scope>
			</struct>

			<!-- Cast expression -->
			<class name="Cast" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="type"/>
					<member name="rvalue" type="Fast::Expression"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Postfix expression -->
			<class name="PostFix" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="Fast::Expression"/>
					<member name="operator" type="operatorKind"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Unary expression -->
			<class name="Unary" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="Fast::Expression"/>
					<member name="operator" type="operatorKind"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
						
			<!-- Binary expression -->
			<class name="Binary" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="lvalue" type="Fast::Expression"/>
					<member name="rvalue" type="Fast::Expression"/>
					<member name="operator" type="operatorKind"/>
					<member name="deref" type="Fast::derefKind" modifiers="local|private"/>
					<method name="fold()" returnType="Fast::Expression"/>
					<method name="setOperator(operatorKind kind)" returnType="void"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
            
            <meta:object name="If" type="class"/>
            
            <!-- Ternary expression -->
            <class name="Ternary" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="condition" type="Fast::Expression"/>
                    <member name="ifTrue" type="Fast::Expression"/>
                    <member name="ifFalse" type="Fast::Expression"/>
                    <member name="ifTrueExpr" type="Fast::Expression" modifiers="local|private"/>
                    <member name="ifFalseExpr" type="Fast::Expression" modifiers="local|private"/>
                    <member name="result" type="Fast::Expression"/>
                    <member name="ifstmt" type="Fast::If" modifiers="local|private"/>
                    <method name="setOperator(operatorKind kind)" returnType="void"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
                </meta:scope>
            </class>
									
			<!-- New expression -->
			<class name="New" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="type" type="type"/>
					<member name="attributes" type="Fast::Expression"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Define statement -->
			<class name="Define" base="Node" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="object" type="Fast::Expression"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Text literal -->
			<class name="String" base="Literal" baseAccess="readonly">
				<meta:scope>
					<method name="init()" returnType="int16"/>
					<method name="construct()" returnType="int16"/>
					<method name="serialize(type dstType,word dst)" returnType="int16"/>
					<member name="value" type="string"/>
					<member name="elements" type="list{Fast::Expression}" modifiers="readonly"/>
					<member name="block" type="Fast::Block" modifiers="readonly"/>
					<member name="scope" type="object" modifiers="readonly"/>
					<method name="getValue()" returnType="word"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- If statement -->
			<class name="If" base="Node" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="condition" type="Fast::Expression"/>
					<member name="trueBranch" type="Fast::Block"/>
					<member name="falseBranch" type="Fast::If"/>
                    <member name="warnUnreachable" type="bool" modifiers="private|local"/>
                    <method name="noWarnUnreachable()"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- While statement -->
			<class name="While" base="Node" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="condition" type="Fast::Expression"/>
					<member name="trueBranch" type="Fast::Block"/>
                    <member name="isUntil" type="bool"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Update statement -->
			<enum name="UpdateKind">
				<meta:scope>
					<constant name="UpdateDefault"/>
					<constant name="UpdateBegin"/>
					<constant name="UpdateEnd"/>
				</meta:scope>
			</enum>
			<class name="Update" base="Node" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="exprList" type="list{Fast::Expression}"/>
					<member name="block" type="Fast::Block"/>
					<member name="from" type="Fast::Expression"/>
					<member name="kind" type="Fast::UpdateKind"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
			
			<!-- Wait expression -->
			<class name="Wait" base="Expression" baseAccess="readonly">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="exprList" type="list{Fast::Expression}"/>
					<member name="timeout" type="Fast::Expression"/>
					<virtual name="toIc(alias{&quot;cx_icProgram&quot;} program,alias{&quot;cx_icStorage&quot;} storage,bool stored)" returnType="alias{&quot;cx_ic&quot;}"/>
				</meta:scope>
			</class>
            
            <!-- Initializer -->
            <enum name="InitializerKind">
                <meta:scope>
                    <constant name="InitStatic"/>
                    <constant name="InitDynamic"/>
                    <constant name="InitExpression"/>
                </meta:scope>
            </enum>
		
			<!-- Initializer stack element -->
			<struct name="InitializerVariable">
				<meta:scope>
					<member name="offset" type="word"/>
					<member name="object" type="Expression"/>
					<!-- Key-values (of associative collections) are serialized to this member -->
					<member name="key" type="word"/>
				</meta:scope>
			</struct>
			
			<struct name="InitializerFrame">
				<meta:scope>
					<member name="location" type="uint32"/>
					<member name="type" type="type"/>
					<member name="isKey" type="bool"/>
					<member name="member" type="member"/>
				</meta:scope>
			</struct>
			
			<class name="Initializer" base="Expression" baseAccess="readonly">
				<meta:scope>
					<member name="variables" type="array{InitializerVariable,64}"/>
					<member name="variableCount" type="uint8"/>
					<member name="frames" type="array{InitializerFrame,64}" modifiers="private|local"/>
					<member name="fp" type="uint8" modifiers="private|local"/>
					<method name="construct()" returnType="int16"/>
					<method name="currentType()" returnType="type"/>
                    <method name="type()" returnType="type"/>
					<virtual name="push()" returnType="int16"/>
					<virtual name="pop()" returnType="int8"/>
                    <virtual name="value(Expression v)" returnType="int16"/>
					<virtual name="member(string name)" returnType="int32"/>
                    <virtual name="pushKey()" returnType="int16"/>
                    <virtual name="popKey()" returnType="int16"/>
                    <virtual name="valueKey(Expression key)" returnType="int16"/>
					<virtual name="define()" returnType="int16"/>
					<virtual name="next()" returnType="int16"/>
                    <method name="initFrame()" returnType="uint16"/>
				</meta:scope>
			</class>
			
			<struct name="StaticInitializerFrame">
				<meta:scope>
					<member name="ptr" type="array{word,64}"/>
                    <member name="keyPtr" type="array{word,64}"/>
				</meta:scope>
			</struct>
			
            <!-- A static initializer represents an object that is initialized during compiletime -->
			<class name="StaticInitializer" base="Initializer">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<member name="frames" type="array{StaticInitializerFrame,64}" modifiers="private|local"/>
					<method name="push()" returnType="int16"/>
					<method name="value(Expression v)" returnType="int16"/>
					<method name="define()" returnType="int16"/>
				</meta:scope>
			</class>
			
			<struct name="DynamicInitializerFrame">
				<meta:scope>
					<member name="expr" type="array{Fast::Expression,64}"/>
                    <member name="keyExpr" type="array{Fast::Expression,64}"/>
                    <member name="sequenceSize" type="Fast::Integer"/>
				</meta:scope>
			</struct>
			
            <!-- A dynamic initializer represents an object that is initialized during runtime -->
			<class name="DynamicInitializer" base="Initializer">
				<meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="assignValue" type="bool"/>
					<member name="frames" type="array{DynamicInitializerFrame,64}" modifiers="private|local"/>
					<method name="push()" returnType="int16"/>
                    <method name="pop()" returnType="int16"/>
					<method name="value(Expression v)" returnType="int16"/>
					<method name="define()" returnType="int16"/>
				</meta:scope>
			</class>
            
            <!-- Recorded Initializer operation -->
            <enum name="InitOperKind">
                <meta:scope>
                    <constant name="InitPush"/>
                    <constant name="InitPop"/>
                    <constant name="InitDefine"/>
                    <constant name="InitValue"/>
                    <constant name="InitMember"/>
                </meta:scope>
            </enum>
            <struct name="InitOper">
                <meta:scope>
                    <member name="kind" type="InitOperKind"/>
                    <member name="expr" type="Fast::Expression"/>
                    <member name="name" type="string"/>
                </meta:scope>
            </struct>
            
            <!-- Record initializer for later evaluation -->
            <class name="InitializerExpression" base="Initializer">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="assignValue" type="bool"/>
                    <member name="operations" type="list{InitOper}" modifiers="private|local"/>
                    <method name="push()" returnType="int16"/>
                    <method name="pop()" returnType="int16"/>
                    <method name="value(Expression v)" returnType="int16"/>
                    <method name="member(string name)" returnType="int32"/>
                    <method name="define()" returnType="int16"/>
                    <method name="insert(Expression variable)" returnType="int16"/>
                </meta:scope>
            </class>
			
			<!-- ParseDeclaration is used to transfer declaration-information within the parser -->
			<struct name="ParserDeclaration">
				<meta:scope>
					<member name="name" type="string"/>
					<member name="storage" type="Fast::Storage"/>
				</meta:scope>
			</struct>
			
			<sequence name="ParserDeclarationSeq" elementType="ParserDeclaration" max="256"/>
			
			<!-- ParserNew is used to transfer new-expression information within the parser -->
			<struct name="ParserNew">
				<meta:scope>
					<member name="kind" type="Fast::nodeKind"/>
					<member name="parent" type="Fast::Expression"/>
					<member name="name" type="Fast::Expression"/>
					<member name="attr" type="Fast::Expression"/>
				</meta:scope>
			</struct>
			
			<!-- Binds function to an implementation -->
			<struct name="Binding">
				<meta:scope>
					<member name="function" type="function"/>
					<member name="impl" type="Fast::Block"/>
				</meta:scope>
			</struct>

			<!-- Keep track of lvalue-stack and whether lvalue is an assignment or not -->
			<struct name="Lvalue">
				<meta:scope>
					<member name="expr" type="Fast::Expression"/>
					<member name="isAssignment" type="bool"/>
				</meta:scope>
			</struct>
				
			<!-- Parser object -->
			<class name="Parser">
				<meta:scope>
					<method name="construct()" returnType="int16"/>
					<method name="destruct()"/>
					<member name="source" type="string"/>
					<member name="preprocessed" type="string" modifiers="readonly"/>
					<member name="filename" type="string"/>
					<member name="repl" type="uint32" modifiers="readonly"/> <!-- Is parser running in interpreted mode -->
					<member name="line" type="uint32" modifiers="readonly"/>
					<member name="column" type="uint32" modifiers="readonly"/>
					<member name="token" type="string" modifiers="readonly"/>
					<member name="block" type="Fast::Block" modifiers="readonly"/>
					<!-- Keep track of block-nesting in 1st pass -->
					<member name="blockCount" type="uint32" modifiers="readonly"/>
					<member name="scope" type="object" modifiers="readonly"/>
					<member name="errors" type="uint32" modifiers="readonly"/>
					<member name="warnings" type="uint32" modifiers="readonly"/>
					<member name="errSet" type="bool" modifiers="readonly|private"/> <!-- If set the last operation on the parser returned an error -->
                    <member name="errLine" type="uint32" modifiers="readonly|private"/>
					<member name="abort" type="bool" modifiers="readonly"/> <!-- If set the last operation on the parser indicated parsing should abort -->
					<member name="bindings" type="list{Fast::Binding}" modifiers="readonly"/>
					<member name="pass" type="uint32" modifiers="private|local"/>
					<method name="collectHeap(word addr)" returnType="void"/>
					<member name="heapCollected" type="list{word}" modifiers="private|local"/>
					<member name="collected" type="list{object}" modifiers="private|local"/>
					<member name="blockPreset" type="bool" modifiers="private|local"/>
					<member name="isLocal" type="bool" modifiers="private|local"/> <!-- If set, next declaration will result in local variable -->				
					<member name="parseSingleExpr" type="bool" modifiers="private|local"/> <!-- If set parser is parsing one instruction -->
					<member name="singleExpr" type="Fast::Expression" modifiers="private|local"/>
					<!-- Due to limitations in the parser sometimes failed resolves can't be immediately reported.
						 This field keeps track of a failed resolve and will be used in a report if it causes issues. -->
					<member name="lastFailedResolve" type="string" modifiers="private|local"/>
					
					<!-- Variables prepared for initializer (maximum of 64 variables can be initialized simultaneously) -->
					<member name="variables" type="array{Fast::Storage,64}" modifiers="private|readonly"/>
					<member name="variableCount" type="uint32" modifiers="private|readonly"/>
					<!-- Have variables been initialized? (required for deciding whether to define or not) -->
					<member name="variablesInitialized" type="bool" modifiers="private|readonly"/>
					
					<!-- If variablePushed is TRUE it means that an object was pushed on the initializer stack without a
						 declaration (using parseInitPushVariable). The next parseInitPush doesn't have to push. -->
					<member name="variablePushed" type="bool" modifiers="private|readonly"/>
					
					<!-- An initializer can have a maximum depth of 64 -->
					<member name="initializers" type="array{Initializer,64}" modifiers="private|local"/>
					<member name="initializerCount" type="int8" modifiers="private|local"/>
                    <member name="initAnonymousId" type="uint32" modifiers="private|local"/>
                    <member name="initDynamic" type="bool" modifiers="private|local"/>
                    
                    <!-- Stage unresolved variables for implicit declaration -->
                    <struct name="stagedId">
                        <meta:scope>
                            <member name="name" type="string"/>
                            <member name="found" type="bool"/>
                            <member name="line" type="uint32"/>
                            <member name="column" type="uint32"/>
                        </meta:scope>
                    </struct>
                    <member name="staged" type="array{stagedId,64}" modifiers="private|local"/>
                    <member name="stagedCount" type="uint32" modifiers="private|local"/>
                    <member name="stagingAllowed" type="bool" modifiers="private|local"/>
					
					<!-- Parser framework functions -->
					<method name="parse()" returnType="uint32"/>
					<function name="parseLine(string expr,object scope,alias{&quot;cx_value*&quot;} value)" returnType="int16"/> <!--  Parse a single line -->
					<method name="parseExpression(string expr,Fast::Block block,object scope,uint32 line,uint32 column)" returnType="Fast::Expression"/>
					<method name="isErrSet()" returnType="bool"/>
					<method name="isAbortSet()" returnType="bool"/>
					<method name="collect(object o)" returnType="void"/>
					<method name="reset()"/>
					<method name="argumentToString(type type,string id,bool reference)" returnType="string"/> <!-- Convert function argument to string -->	

					<!-- Scope management -->
					<method name="pushScope()" returnType="object"/>
					<method name="popScope(object previous)"/>
					<method name="pushPackage(string name)" returnType="int16"/>
					
					<!-- Lookup -->
					<method name="lookup(string id,object source)" returnType="Fast::Expression"/>
					
					<!-- Blocks management -->
					<method name="blockPush(bool presetBlock)" returnType="Fast::Block"/>
					<method name="blockPop()"/>
					<method name="addStatement(Fast::Node statement)"/>
					
					<!-- Declaration -->
					<method name="declaration(type type,string id,bool isReference)" returnType="Storage"/>
					<method name="declareFunction(type returnType,string id,type kind,bool returnsReference)" returnType="Storage"/>
					<method name="declareFunctionParams(Storage function)" returnType="Fast::Block"/>
					<method name="define()" returnType="int16"/>
					<method name="defineScope()" returnType="int16"/>
					<method name="defineVariable(Storage object)" returnType="int16"/>
					
					<!-- Bind function to implementation -->
					<method name="bind(Fast::Storage function,Fast::Block block)" returnType="int16"/>
					<method name="bindOneliner(Fast::Storage function,Fast::Block block,Fast::Expression expr)" returnType="int16"/>

					<!-- Finalize bound functions -->
					<method name="finalize(alias{&quot;cx_icProgram&quot;} program)" returnType="int16"/>
                    
                    <method name="initStage(string id,bool found)"/>
                    <method name="initDeclareStaged(Fast::Expression expr)"/>
                    <method name="initPushStatic()" returnType="int16"/>
                    <method name="initPushExpression()" returnType="Expression"/>
					<method name="initPush()" returnType="int16"/>
					<method name="initPushIdentifier(Expression type)" returnType="Expression"/>
					<method name="initPop()" returnType="int16"/>
					<method name="initValue(Expression expr)" returnType="int16"/>
					<method name="initMember(string member)" returnType="int16"/>
					<method name="initKeyValuePush()" returnType="int16"/>
					<method name="initKeyValuePop()" returnType="int16"/>
					<method name="initKeyValueSet(Fast::Expression expr)" returnType="int16"/>
					
                    <!-- Set lvalue -->
                    <member name="lvalue" type="array{Fast::Lvalue,64}" modifiers="private|local"/>
                    <member name="lvalueSp" type="int32" modifiers="private|local"/>
                    <method name="pushLvalue(Fast::Expression lvalue,bool isAssignment)"/>
                    <method name="pushReturnAsLvalue(function function)"/>
                    <method name="popLvalue()"/>
                    <method name="getLvalue(bool assignment)" returnType="Fast::Expression"/>
                    <method name="getLvalueType(bool assignment)" returnType="type"/>

                    <!-- This complex type is used to lookup member identifiers in element expression -->
                    <member name="complexType" type="array{type,64}" modifiers="private|local"/>
                    <member name="complexTypeSp" type="int32" modifiers="private|local"/>
                    <method name="pushComplexType(Fast::Expression lvalue)"/>
                    <method name="popComplexType()"/>
                    <method name="getComplexType()" returnType="type"/>

					<!-- Observer -->
					<method name="observerPush()"/>
					<method name="observerDeclaration(string id,Fast::Expression object,eventMask mask,Fast::Object dispatcher)" returnType="Storage"/>
					
					<!-- Foreach -->
					<method name="foreach(string loopId,Fast::Expression collection)" returnType="int16"/>
															
					<!-- Postfix expressions -->
					<method name="callExpr(Fast::Expression function,Fast::Expression arguments)" returnType="Fast::Expression"/>
					<method name="memberExpr(Fast::Expression lvalue,Fast::Expression rvalue)" returnType="Fast::Expression"/>
					<method name="elementExpr(Fast::Expression lvalue,Fast::Expression rvalue)" returnType="Fast::Expression"/>
					<method name="castExpr(type lvalue,Fast::Expression rvalue)" returnType="Fast::Expression"/>
					
					<!-- Arithmic expressions -->
					<method name="postfixExpr(Fast::Expression lvalue,operatorKind operator)" returnType="Fast::Expression"/>
					<method name="unaryExpr(Fast::Expression lvalue,operatorKind operator)" returnType="Fast::Expression"/>
					<method name="binaryExpr(Fast::Expression lvalues,Fast::Expression rvalues,operatorKind operator)" returnType="Fast::Node"/>
                    <method name="ternaryExpr(Fast::Expression cond,Fast::Expression iftrue,Fast::Expression iffalse)" returnType="Fast::Expression"/>
					
					<!-- Wait expression -->
					<method name="waitExpr(Fast::Expression expr,Fast::Expression timeout)" returnType="Fast::Expression"/>
					
					<!-- Loops and conditional statements -->
					<method name="ifStatement(Fast::Expression condition,Fast::Block trueBranch,Fast::If falseBranch)" returnType="Fast::Node"/>
					<method name="whileStatement(Fast::Expression condition,Fast::Block trueBranch,bool isUntil)" returnType="Fast::Node"/>	
					
					<!-- Update -->
					<method name="updateStatement(Fast::Expression expr,Fast::Block block)" returnType="Fast::Node"/>				
				</meta:scope>
			</class>
		</meta:scope>
	</meta:scope>
</meta>
