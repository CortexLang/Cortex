// Declarations
//
// The hyve language has a declarative syntax for instantiating objects, making it 
// suitable as a definition language for the hyve framework. Everything in hyve is 
// instantiated with a declaration, including types.
//
// Note in the following example that there is no difference in syntax between
// instantiating a type and a 'regular' object. Types are just like regular objects in the
// hyve language and they are instantiated by using the meta-objects in the hyve::lang 
// namespace.
//
// Declarations can either implicitly or explicitly (by name) assign members. The order in
// which members are supplied when done implicitly is the order of specification. Note
// that only public members can be assigned in a declaration. 
//
// When you are unsure about the order in which members can be implicitly assigned you can
// load the module that contains your interface in dbsh and print the type. Dbsh will
// show the default initializer for that type which contains the correct member order.

// Create class 'Point' (or rather, create object 'Point' of type 'class')
//    Create two member objects in the scope of Point.
class Point::
	member x, y : uint32; // Implicit assignment (member 'type' is assigned)

// Point3D inherits from Point (or rather, has its base-member set to Point)
class Point3D : Point::
	member z : type:uint32; // Explicit assignment
	
// Create Point3D object (implicit assignment)
Point3D p1 : 10, 20, 30; 

// Create Point3D object (explicit assignment)
Point3D p2 : x:10 y:20 z:30;
